/**
 * Generated by @openapi-codegen
 *
 * @version 0.1.0
 */
import * as reactQuery from '@tanstack/react-query'
import { useRfcllmapiContext, RfcllmapiContext } from './rfcllmapiContext'
import type * as Fetcher from './rfcllmapiFetcher'
import { rfcllmapiFetch } from './rfcllmapiFetcher'
import type * as Schemas from './rfcllmapiSchemas'
import { useState } from 'react'
import { RFCLLMEP } from '../config'

export type LoginForAccessTokenTokenPostError = Fetcher.ErrorWrapper<{
  status: 422
  payload: Schemas.HTTPValidationError
}>

export type LoginForAccessTokenTokenPostVariables =
  RfcllmapiContext['fetcherOptions']

export const useAuth = () => {
  const [user, setState] = useState<{ [x: string]: any } | string | undefined>(
    undefined,
  )
  const [error, setError] = useState<{ [x: string]: any } | string | undefined>(
    undefined,
  )
  const login = async (username: string, password: string): Promise<any> => {
    const res = await fetch(`http://127.0.0.1:8000/oauth/login`, {
      headers: {
        accept: 'application/json',
        'content-type': 'application/x-www-form-urlencoded',
      },
      body: `grant_type=password&username=${username}&password=${password}`,
      method: 'POST',
      mode: 'cors',
    })

    if (res.status !== 200) {
      setError(res.json())
      setState(undefined)
      localStorage.removeItem('rfcllmapitoken')
    } else {
      setState(res)
      localStorage.setItem('rfcllmapitoken', JSON.stringify(res))
    }
  }
  const logout = () => {
    localStorage.removeItem('rfcllmapitoken')
    setState(undefined)
    setError(undefined)
  }

  return {
    token: user,
    error,
    login,
    logout,
  }
}

export type ReadUsersMeUsersMeGetError = Fetcher.ErrorWrapper<undefined>
export type ReadUsersMeUsersMeGetVariables = RfcllmapiContext['fetcherOptions']

export const fetchReadUsersMeUsersMeGet = (
  variables: ReadUsersMeUsersMeGetVariables,
  signal?: AbortSignal,
) =>
  rfcllmapiFetch<
    Schemas.User,
    ReadUsersMeUsersMeGetError,
    undefined,
    {},
    {},
    {}
  >({
    url: '/users/me/',
    method: 'get',
    ...variables,
    signal,
  })

export const useReadUsersMeUsersMeGet = <TData = Schemas.User>(
  variables: ReadUsersMeUsersMeGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.User, ReadUsersMeUsersMeGetError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRfcllmapiContext(options)
  return reactQuery.useQuery<Schemas.User, ReadUsersMeUsersMeGetError, TData>({
    queryKey: queryKeyFn({
      path: '/users/me/',
      operationId: 'readUsersMeUsersMeGet',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadUsersMeUsersMeGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  })
}

export type ReadOwnItemsUsersMeItemsGetError = Fetcher.ErrorWrapper<undefined>
export type ReadOwnItemsUsersMeItemsGetVariables =
  RfcllmapiContext['fetcherOptions']

export const fetchReadOwnItemsUsersMeItemsGet = (
  variables: ReadOwnItemsUsersMeItemsGetVariables,
  signal?: AbortSignal,
) =>
  rfcllmapiFetch<void, ReadOwnItemsUsersMeItemsGetError, undefined, {}, {}, {}>(
    {
      url: '/users/me/items/',
      method: 'get',
      ...variables,
      signal,
    },
  )

export const useReadOwnItemsUsersMeItemsGet = <TData = void>(
  variables: ReadOwnItemsUsersMeItemsGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, ReadOwnItemsUsersMeItemsGetError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useRfcllmapiContext(options)
  return reactQuery.useQuery<void, ReadOwnItemsUsersMeItemsGetError, TData>({
    queryKey: queryKeyFn({
      path: '/users/me/items/',
      operationId: 'readOwnItemsUsersMeItemsGet',
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadOwnItemsUsersMeItemsGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  })
}

export type SearchIetfSearchQueryIetfPostError = Fetcher.ErrorWrapper<{
  status: 422
  payload: Schemas.HTTPValidationError
}>

export type SearchIetfSearchQueryIetfPostVariables = {
  body: Schemas.SearchRequestDTO
} & RfcllmapiContext['fetcherOptions']

export const fetchSearchIetfSearchQueryIetfPost = (
  variables: SearchIetfSearchQueryIetfPostVariables,
  signal?: AbortSignal,
) =>
  rfcllmapiFetch<
    void,
    SearchIetfSearchQueryIetfPostError,
    Schemas.SearchRequestDTO,
    {},
    {},
    {}
  >({
    url: '/search/query/ietf',
    method: 'post',
    ...variables,
    signal,
  })

export const useSearchIetfSearchQueryIetfPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      SearchIetfSearchQueryIetfPostError,
      SearchIetfSearchQueryIetfPostVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useRfcllmapiContext()
  return reactQuery.useMutation<
    void,
    SearchIetfSearchQueryIetfPostError,
    SearchIetfSearchQueryIetfPostVariables
  >({
    mutationFn: (variables: SearchIetfSearchQueryIetfPostVariables) =>
      fetchSearchIetfSearchQueryIetfPost({ ...fetcherOptions, ...variables }),
    ...options,
  })
}

export type SearchRfcSearchRfcPostError = Fetcher.ErrorWrapper<{
  status: 422
  payload: Schemas.HTTPValidationError
}>

export type SearchRfcSearchRfcPostVariables = {
  body: Schemas.SearchRequestDTO
} & RfcllmapiContext['fetcherOptions']

export const fetchSearchRfcSearchRfcPost = (
  variables: SearchRfcSearchRfcPostVariables,
  signal?: AbortSignal,
) =>
  rfcllmapiFetch<
    void,
    SearchRfcSearchRfcPostError,
    Schemas.SearchRequestDTO,
    {},
    {},
    {}
  >({
    url: '/search/rfc',
    method: 'post',
    ...variables,
    signal,
  })

export const useSearchRfcSearchRfcPost = async (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      SearchRfcSearchRfcPostError,
      SearchRfcSearchRfcPostVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useRfcllmapiContext({ enabled: true })
  return reactQuery.useMutation<
    void,
    SearchRfcSearchRfcPostError,
    SearchRfcSearchRfcPostVariables
  >({
    mutationFn: async (variables: SearchRfcSearchRfcPostVariables) => {
      console.log(variables, options)
      return await fetchSearchRfcSearchRfcPost({
        ...fetcherOptions,
        ...variables,
      })
    },
    ...options,
  })
}

export type QaSingleContigiousQaSingleContigiousPostError =
  Fetcher.ErrorWrapper<{
    status: 422
    payload: Schemas.HTTPValidationError
  }>

export type QaSingleContigiousQaSingleContigiousPostVariables = {
  body: Schemas.InquiryDTO
} & RfcllmapiContext['fetcherOptions']

export const fetchQaSingleContigiousQaSingleContigiousPost = (
  variables: QaSingleContigiousQaSingleContigiousPostVariables,
  signal?: AbortSignal,
) =>
  rfcllmapiFetch<
    void,
    QaSingleContigiousQaSingleContigiousPostError,
    Schemas.InquiryDTO,
    {},
    {},
    {}
  >({ url: '/qa/single/contigious', method: 'post', ...variables, signal })

export const useQaSingleContigiousQaSingleContigiousPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      QaSingleContigiousQaSingleContigiousPostError,
      QaSingleContigiousQaSingleContigiousPostVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useRfcllmapiContext()
  return reactQuery.useMutation<
    void,
    QaSingleContigiousQaSingleContigiousPostError,
    QaSingleContigiousQaSingleContigiousPostVariables
  >({
    mutationFn: (
      variables: QaSingleContigiousQaSingleContigiousPostVariables,
    ) =>
      fetchQaSingleContigiousQaSingleContigiousPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  })
}

export type QueryOperation =
  | {
      path: '/users/me/'
      operationId: 'readUsersMeUsersMeGet'
      variables: ReadUsersMeUsersMeGetVariables
    }
  | {
      path: '/users/me/items/'
      operationId: 'readOwnItemsUsersMeItemsGet'
      variables: ReadOwnItemsUsersMeItemsGetVariables
    }
